{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ready, crypto_secretbox_NONCEBYTES, crypto_secretbox_MACBYTES } from 'libsodium-wrappers';\nimport { BEACON_VERSION } from '../../constants';\nimport { decryptCryptoboxPayload, encryptCryptoboxPayload, generateGUID } from '@airgap/beacon-utils';\nimport { CommunicationClient } from './CommunicationClient';\n/**\n * @internalapi\n *\n *\n */\nexport class MessageBasedClient extends CommunicationClient {\n  constructor(name, keyPair) {\n    super(keyPair);\n    this.name = name;\n    this.init().catch(console.error);\n  }\n  /**\n   * start the client and make sure all dependencies are ready\n   */\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield ready;\n    });\n  }\n  /**\n   * Get the pairing request information. This will be shared with the peer during the connection setup\n   */\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        id: yield generateGUID(),\n        type: 'postmessage-pairing-request',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey()\n      };\n    });\n  }\n  /**\n   * Get the pairing response information. This will be shared with the peer during the connection setup\n   */\n  getPairingResponseInfo(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        id: request.id,\n        type: 'postmessage-pairing-response',\n        name: this.name,\n        version: request.version,\n        publicKey: yield this.getPublicKey()\n      };\n    });\n  }\n  /**\n   * Unsubscribe from encrypted messages from a specific peer\n   *\n   * @param senderPublicKey\n   */\n  unsubscribeFromEncryptedMessage(senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const listener = this.activeListeners.get(senderPublicKey);\n      if (!listener) {\n        return;\n      }\n      this.activeListeners.delete(senderPublicKey);\n    });\n  }\n  /**\n   * Unsubscribe from all encrypted messages\n   */\n  unsubscribeFromEncryptedMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.activeListeners.clear();\n    });\n  }\n  /**\n   * Decrypt a message from a specific peer\n   *\n   * @param senderPublicKey\n   * @param payload\n   */\n  decryptMessage(senderPublicKey, payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedRx\n      } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n      const hexPayload = Buffer.from(payload, 'hex');\n      if (hexPayload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n        try {\n          return yield decryptCryptoboxPayload(hexPayload, sharedRx);\n        } catch (decryptionError) {\n          /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n        }\n      }\n      throw new Error('Could not decrypt message');\n    });\n  }\n  /**\n   * Encrypt a message for a specific publicKey (receiver)\n   *\n   * @param recipientPublicKey\n   * @param message\n   */\n  encryptMessage(recipientPublicKey, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedTx\n      } = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair.privateKey);\n      return encryptCryptoboxPayload(message, sharedTx);\n    });\n  }\n}","map":{"version":3,"names":["ready","crypto_secretbox_NONCEBYTES","crypto_secretbox_MACBYTES","BEACON_VERSION","decryptCryptoboxPayload","encryptCryptoboxPayload","generateGUID","CommunicationClient","MessageBasedClient","constructor","name","keyPair","init","catch","console","error","start","getPairingRequestInfo","id","type","version","publicKey","getPublicKey","getPairingResponseInfo","request","unsubscribeFromEncryptedMessage","senderPublicKey","listener","activeListeners","get","delete","unsubscribeFromEncryptedMessages","clear","decryptMessage","payload","sharedRx","createCryptoBoxServer","privateKey","hexPayload","Buffer","from","length","decryptionError","Error","encryptMessage","recipientPublicKey","message","sharedTx","createCryptoBoxClient"],"sources":["../../../../src/transports/clients/MessageBasedClient.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SACEA,KAAK,EAELC,2BAA2B,EAC3BC,yBAAyB,QACpB,oBAAoB;AAC3B,SAASC,cAAc,QAAQ,iBAAiB;AAChD,SACEC,uBAAuB,EACvBC,uBAAuB,EACvBC,YAAY,QACP,sBAAsB;AAC7B,SAASC,mBAAmB,QAAQ,uBAAuB;AAG3D;;;;;AAKA,OAAM,MAAgBC,kBAAmB,SAAQD,mBAAmB;EAMlEE,YAA+BC,IAAY,EAAEC,OAAgB;IAC3D,KAAK,CAACA,OAAO,CAAC;IADe,KAAAD,IAAI,GAAJA,IAAI;IAEjC,IAAI,CAACE,IAAI,EAAE,CAACC,KAAK,CAACC,OAAO,CAACC,KAAK,CAAC;EAClC;EAEA;;;EAGaC,KAAKA,CAAA;;MAChB,MAAMhB,KAAK;IACb,CAAC;;EAED;;;EAGaiB,qBAAqBA,CAAA;;MAChC,OAAO;QACLC,EAAE,EAAE,MAAMZ,YAAY,EAAE;QACxBa,IAAI,EAAE,6BAA6B;QACnCT,IAAI,EAAE,IAAI,CAACA,IAAI;QACfU,OAAO,EAAEjB,cAAc;QACvBkB,SAAS,EAAE,MAAM,IAAI,CAACC,YAAY;OACnC;IACH,CAAC;;EAED;;;EAGaC,sBAAsBA,CACjCC,OAAkC;;MAElC,OAAO;QACLN,EAAE,EAAEM,OAAO,CAACN,EAAE;QACdC,IAAI,EAAE,8BAA8B;QACpCT,IAAI,EAAE,IAAI,CAACA,IAAI;QACfU,OAAO,EAAEI,OAAO,CAACJ,OAAO;QACxBC,SAAS,EAAE,MAAM,IAAI,CAACC,YAAY;OACnC;IACH,CAAC;;EAED;;;;;EAKaG,+BAA+BA,CAACC,eAAuB;;MAClE,MAAMC,QAAQ,GAAG,IAAI,CAACC,eAAe,CAACC,GAAG,CAACH,eAAe,CAAC;MAC1D,IAAI,CAACC,QAAQ,EAAE;QACb;;MAGF,IAAI,CAACC,eAAe,CAACE,MAAM,CAACJ,eAAe,CAAC;IAC9C,CAAC;;EAED;;;EAGaK,gCAAgCA,CAAA;;MAC3C,IAAI,CAACH,eAAe,CAACI,KAAK,EAAE;IAC9B,CAAC;;EAED;;;;;;EAMgBC,cAAcA,CAACP,eAAuB,EAAEQ,OAAe;;MACrE,MAAM;QAAEC;MAAQ,CAAE,GAAG,MAAM,IAAI,CAACC,qBAAqB,CAACV,eAAe,EAAE,IAAI,CAACf,OAAO,CAAC0B,UAAU,CAAC;MAE/F,MAAMC,UAAU,GAAGC,MAAM,CAACC,IAAI,CAACN,OAAO,EAAE,KAAK,CAAC;MAE9C,IAAII,UAAU,CAACG,MAAM,IAAIxC,2BAA2B,GAAGC,yBAAyB,EAAE;QAChF,IAAI;UACF,OAAO,MAAME,uBAAuB,CAACkC,UAAU,EAAEH,QAAQ,CAAC;SAC3D,CAAC,OAAOO,eAAe,EAAE;UACxB;QAAA;;MAIJ,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;IAC9C,CAAC;;EAED;;;;;;EAMgBC,cAAcA,CAACC,kBAA0B,EAAEC,OAAe;;MACxE,MAAM;QAAEC;MAAQ,CAAE,GAAG,MAAM,IAAI,CAACC,qBAAqB,CACnDH,kBAAkB,EAClB,IAAI,CAAClC,OAAO,CAAC0B,UAAU,CACxB;MAED,OAAOhC,uBAAuB,CAACyC,OAAO,EAAEC,QAAQ,CAAC;IACnD,CAAC"},"metadata":{},"sourceType":"module"}