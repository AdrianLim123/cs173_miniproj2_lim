{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ready, crypto_generichash, from_string, crypto_sign_detached, crypto_secretbox_NONCEBYTES, crypto_secretbox_MACBYTES } from 'libsodium-wrappers';\nimport axios from 'axios';\nimport { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from '@airgap/beacon-utils';\nimport { MatrixClient } from '../matrix-client/MatrixClient';\nimport { MatrixClientEventType } from '../matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from '../matrix-client/models/MatrixMessage';\nimport { StorageKey } from '@airgap/beacon-types';\nimport { PeerManager, BEACON_VERSION, getSenderId, Logger, CommunicationClient } from '@airgap/beacon-core';\nimport { ExposedPromise, generateGUID } from '@airgap/beacon-utils';\nconst logger = new Logger('P2PCommunicationClient');\nexport const KNOWN_RELAY_SERVERS = ['beacon-node-1.diamond.papers.tech', 'beacon-node-1.sky.papers.tech', 'beacon-node-2.sky.papers.tech', 'beacon-node-1.hope.papers.tech', 'beacon-node-1.hope-2.papers.tech', 'beacon-node-1.hope-3.papers.tech', 'beacon-node-1.hope-4.papers.tech', 'beacon-node-1.hope-5.papers.tech'];\n/**\n * @internalapi\n */\nexport class P2PCommunicationClient extends CommunicationClient {\n  constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {\n    super(keyPair);\n    this.name = name;\n    this.replicationCount = replicationCount;\n    this.storage = storage;\n    this.iconUrl = iconUrl;\n    this.appUrl = appUrl;\n    this.client = new ExposedPromise();\n    this.activeListeners = new Map();\n    this.ignoredRooms = [];\n    this.loginCounter = 0;\n    logger.log('constructor', 'P2PCommunicationClient created');\n    const nodes = matrixNodes.length > 0 ? matrixNodes : KNOWN_RELAY_SERVERS;\n    this.ENABLED_RELAY_SERVERS = nodes;\n  }\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: yield generateGUID(),\n        type: 'p2p-pairing-request',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey(),\n        relayServer: yield this.getRelayServer()\n      };\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n      return info;\n    });\n  }\n  getPairingResponseInfo(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: request.id,\n        type: 'p2p-pairing-response',\n        name: this.name,\n        version: request.version,\n        publicKey: yield this.getPublicKey(),\n        relayServer: yield this.getRelayServer()\n      };\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n      return info;\n    });\n  }\n  getRelayServer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.relayServer) {\n        return this.relayServer.promise;\n      } else {\n        this.relayServer = new ExposedPromise();\n      }\n      const node = yield this.storage.get(StorageKey.MATRIX_SELECTED_NODE);\n      if (node && node.length > 0) {\n        this.relayServer.resolve(node);\n        return node;\n      }\n      const nodes = [...this.ENABLED_RELAY_SERVERS];\n      while (nodes.length > 0) {\n        const index = Math.floor(Math.random() * nodes.length);\n        const server = nodes[index];\n        try {\n          yield axios.get(`https://${server}/_matrix/client/versions`);\n          this.storage.set(StorageKey.MATRIX_SELECTED_NODE, server).catch(error => logger.log(error));\n          this.relayServer.resolve(server);\n          return server;\n        } catch (relayError) {\n          logger.log(`Ignoring server \"${server}\", trying another one...`);\n          nodes.splice(index, 1);\n        }\n      }\n      this.relayServer.reject(`No matrix server reachable!`);\n      throw new Error(`No matrix server reachable!`);\n    });\n  }\n  tryJoinRooms(roomId) {\n    let retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield (yield this.client.promise).joinRooms(roomId);\n      } catch (error) {\n        if (retry <= 10 && error.errcode === 'M_FORBIDDEN') {\n          // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.\n          logger.log(`Retrying to join...`, error);\n          setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            yield this.tryJoinRooms(roomId, retry + 1);\n          }), 200);\n        } else {\n          logger.log(`Failed to join after ${retry} tries.`, error);\n        }\n      }\n    });\n  }\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('start', 'starting client');\n      yield ready;\n      const loginRawDigest = crypto_generichash(32, from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));\n      const rawSignature = crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);\n      logger.log('start', `connecting to server`);\n      const relayServer = yield this.getRelayServer();\n      const client = MatrixClient.create({\n        baseUrl: `https://${relayServer}`,\n        storage: this.storage\n      });\n      this.initialListener = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {\n          if (this.initialEvent.timestamp < event.timestamp) {\n            this.initialEvent = event;\n          }\n        } else {\n          this.initialEvent = event;\n        }\n      });\n      client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);\n      client.subscribe(MatrixClientEventType.INVITE, event => __awaiter(this, void 0, void 0, function* () {\n        let member;\n        if (event.content.members.length === 1) {\n          // If there is only one member we know it's a new room\n          // TODO: Use the \"sender\" of the event instead\n          member = event.content.members[0];\n        }\n        yield this.tryJoinRooms(event.content.roomId);\n        if (member) {\n          yield this.updateRelayServer(member);\n          yield this.updatePeerRoom(member, event.content.roomId);\n        }\n      }));\n      logger.log('start', 'login', yield this.getPublicKeyHash(), 'on', relayServer);\n      try {\n        yield client.start({\n          id: yield this.getPublicKeyHash(),\n          password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,\n          deviceId: toHex(this.keyPair.publicKey)\n        });\n      } catch (error) {\n        console.log('ERROR, RETRYING');\n        yield this.reset(); // If we can't log in, let's reset\n        console.log('TRYING AGAIN');\n        if (this.loginCounter <= this.ENABLED_RELAY_SERVERS.length) {\n          this.loginCounter++;\n          this.start();\n          return;\n        } else {\n          throw new Error('Too many login attempts. Try again later.');\n        }\n      }\n      console.log('client is ready');\n      this.client.resolve(client);\n    });\n  }\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.client.isResolved()) {\n        yield (yield this.client.promise).stop().catch(error => logger.error(error));\n      }\n      yield this.reset();\n    });\n  }\n  reset() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.storage.delete(StorageKey.MATRIX_PEER_ROOM_IDS).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_PRESERVED_STATE).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_SELECTED_NODE).catch(error => logger.log(error));\n      // Instead of resetting everything, maybe we should make sure a new instance is created?\n      this.relayServer = undefined;\n      this.client = new ExposedPromise();\n      this.initialEvent = undefined;\n      this.initialListener = undefined;\n    });\n  }\n  listenForEncryptedMessage(senderPublicKey, messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.activeListeners.has(senderPublicKey)) {\n        return;\n      }\n      const {\n        sharedRx\n      } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n      const callbackFunction = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {\n          let payload;\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n          try {\n            payload = Buffer.from(event.content.message.content, 'hex');\n            // content can be non-hex if it's a connection open request\n          } catch (_a) {\n            /* */\n          }\n          if (payload && payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n            try {\n              const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedRx);\n              // logger.log(\n              //   'listenForEncryptedMessage',\n              //   'encrypted message received',\n              //   decryptedMessage,\n              //   await new Serializer().deserialize(decryptedMessage)\n              // )\n              // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n              // TODO: Add check for correct decryption key / sender ID\n              messageCallback(decryptedMessage);\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      });\n      this.activeListeners.set(senderPublicKey, callbackFunction);\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n      const lastEvent = this.initialEvent;\n      if (lastEvent && lastEvent.timestamp && new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000) {\n        logger.log('listenForEncryptedMessage', 'Handling previous event');\n        yield callbackFunction(lastEvent);\n      } else {\n        logger.log('listenForEncryptedMessage', 'No previous event found');\n      }\n      const initialListener = this.initialListener;\n      if (initialListener) {\n        ;\n        (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, initialListener);\n      }\n      this.initialListener = undefined;\n      this.initialEvent = undefined;\n    });\n  }\n  unsubscribeFromEncryptedMessage(senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const listener = this.activeListeners.get(senderPublicKey);\n      if (!listener) {\n        return;\n      }\n      ;\n      (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, listener);\n      this.activeListeners.delete(senderPublicKey);\n    });\n  }\n  unsubscribeFromEncryptedMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      ;\n      (yield this.client.promise).unsubscribeAll(MatrixClientEventType.MESSAGE);\n      this.activeListeners.clear();\n    });\n  }\n  sendMessage(message, peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedTx\n      } = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair.privateKey);\n      const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, peer.relayServer);\n      const roomId = yield this.getRelevantRoom(recipient);\n      // Before we send the message, we have to wait for the join to be accepted.\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n      const encryptedMessage = yield encryptCryptoboxPayload(message, sharedTx);\n      (yield this.client.promise).sendTextMessage(roomId, encryptedMessage).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          (yield this.client.promise).sendTextMessage(newRoomId, encryptedMessage).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendMessage`, `inner error`, error2);\n          }));\n        } else {\n          logger.log(`sendMessage`, `not forbidden`, error);\n        }\n      }));\n    });\n  }\n  updatePeerRoom(sender, roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n      const split = sender.split(':');\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const room = roomIds[sender];\n      if (room && room[1]) {\n        // If we have a room already, let's ignore it. We need to do this, otherwise it will be loaded from the matrix cache.\n        this.ignoredRooms.push(room[1]);\n      }\n      roomIds[sender] = roomId;\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n      // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n    });\n  }\n\n  deleteRoomIdFromRooms(roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const newRoomIds = Object.entries(roomIds).filter(entry => entry[1] !== roomId).reduce((pv, cv) => Object.assign(Object.assign({}, pv), {\n        [cv[0]]: cv[1]\n      }), {});\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds);\n      // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n      this.ignoredRooms.push(roomId);\n    });\n  }\n  listenForChannelOpening(messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      ;\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {\n          logger.log(`listenForChannelOpening`, `channel opening`, JSON.stringify(event));\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n          const splits = event.content.message.content.split(':');\n          const payload = Buffer.from(splits[splits.length - 1], 'hex');\n          if (payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n            try {\n              const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n              messageCallback(Object.assign(Object.assign({}, pairingResponse), {\n                senderId: yield getSenderId(pairingResponse.publicKey)\n              }));\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      }));\n    });\n  }\n  waitForJoin(roomId) {\n    let retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return __awaiter(this, void 0, void 0, function* () {\n      // Rooms are updated as new events come in. `client.getRoomById` only accesses memory, it does not do any network requests.\n      // TODO: Improve to listen to \"JOIN\" event\n      const room = yield (yield this.client.promise).getRoomById(roomId);\n      logger.log(`waitForJoin`, `Currently ${room.members.length} members, we need at least 2`);\n      if (room.members.length >= 2 || room.members.length === 0) {\n        // 0 means it's an unknown room, we don't need to wait\n        return;\n      } else {\n        if (retry <= 200) {\n          // On mobile, due to app switching, we potentially have to wait for a long time\n          logger.log(`Waiting for join... Try: ${retry}`);\n          return new Promise(resolve => {\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n              resolve(this.waitForJoin(roomId, retry + 1));\n            }), 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second\n          });\n        } else {\n          throw new Error(`No one joined after ${retry} tries.`);\n        }\n      }\n    });\n  }\n  sendPairingResponse(pairingRequest) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`sendPairingResponse`);\n      const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, pairingRequest.relayServer);\n      // We force room creation here because if we \"re-pair\", we need to make sure that we don't send it to an old room.\n      const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n      yield this.updatePeerRoom(recipient, roomId);\n      // Before we send the message, we have to wait for the join to be accepted.\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n      // TODO: remove v1 backwards-compatibility\n      const message = typeof pairingRequest.version === 'undefined' ? yield this.getPublicKey() // v1\n      : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest)); // v2\n      const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);\n      const msg = ['@channel-open', recipient, encryptedMessage].join(':');\n      (yield this.client.promise).sendTextMessage(roomId, msg).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          (yield this.client.promise).sendTextMessage(newRoomId, msg).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendMessage`, `inner error`, error2);\n          }));\n        } else {\n          logger.log(`sendMessage`, `not forbidden`, error);\n        }\n      }));\n    });\n  }\n  isTextMessage(content) {\n    return content.message.type === MatrixMessageType.TEXT;\n  }\n  updateRelayServer(sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n      const split = sender.split(':');\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n      const senderHash = split.shift();\n      const relayServer = split.join(':');\n      const manager = localStorage.getItem('beacon:communication-peers-dapp') ? new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP) : new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_WALLET);\n      const peers = yield manager.getPeers();\n      const promiseArray = peers.map(peer => __awaiter(this, void 0, void 0, function* () {\n        const hash = `@${yield getHexHash(Buffer.from(peer.publicKey, 'hex'))}`;\n        if (hash === senderHash) {\n          if (peer.relayServer !== relayServer) {\n            peer.relayServer = relayServer;\n            yield manager.addPeer(peer);\n          }\n        }\n      }));\n      yield Promise.all(promiseArray);\n    });\n  }\n  isChannelOpenMessage(content) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);\n    });\n  }\n  isSender(event, senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);\n    });\n  }\n  getRelevantRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      let roomId = roomIds[recipient];\n      if (!roomId) {\n        logger.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);\n        const room = yield this.getRelevantJoinedRoom(recipient);\n        roomId = room.id;\n        roomIds[recipient] = room.id;\n        yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n      }\n      logger.log(`getRelevantRoom`, `Using room ${roomId}`);\n      return roomId;\n    });\n  }\n  getRelevantJoinedRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const joinedRooms = yield (yield this.client.promise).joinedRooms;\n      logger.log('checking joined rooms', joinedRooms, recipient);\n      const relevantRooms = joinedRooms.filter(roomElement => !this.ignoredRooms.some(id => roomElement.id === id)).filter(roomElement => roomElement.members.some(member => member === recipient));\n      let room;\n      // We always create a new room if one has been ignored. This is because if we ignore one, we know the server state changed.\n      // So we cannot trust the current sync state. This can be removed once we have a method to properly clear and refresh the sync state.\n      if (relevantRooms.length === 0 || this.ignoredRooms.length > 0) {\n        logger.log(`getRelevantJoinedRoom`, `no relevant rooms found, creating new one`);\n        const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n        room = yield (yield this.client.promise).getRoomById(roomId);\n        logger.log(`getRelevantJoinedRoom`, `waiting for other party to join room: ${room.id}`);\n        yield this.waitForJoin(roomId);\n        logger.log(`getRelevantJoinedRoom`, `new room created and peer invited: ${room.id}`);\n      } else {\n        room = relevantRooms[0];\n        logger.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);\n      }\n      return room;\n    });\n  }\n}","map":{"version":3,"names":["ready","crypto_generichash","from_string","crypto_sign_detached","crypto_secretbox_NONCEBYTES","crypto_secretbox_MACBYTES","axios","getHexHash","toHex","recipientString","openCryptobox","encryptCryptoboxPayload","decryptCryptoboxPayload","MatrixClient","MatrixClientEventType","MatrixMessageType","StorageKey","PeerManager","BEACON_VERSION","getSenderId","Logger","CommunicationClient","ExposedPromise","generateGUID","logger","KNOWN_RELAY_SERVERS","P2PCommunicationClient","constructor","name","keyPair","replicationCount","storage","matrixNodes","iconUrl","appUrl","client","activeListeners","Map","ignoredRooms","loginCounter","log","nodes","length","ENABLED_RELAY_SERVERS","getPairingRequestInfo","info","id","type","version","publicKey","getPublicKey","relayServer","getRelayServer","icon","getPairingResponseInfo","request","promise","node","get","MATRIX_SELECTED_NODE","resolve","index","Math","floor","random","server","set","catch","error","relayError","splice","reject","Error","tryJoinRooms","roomId","retry","arguments","undefined","joinRooms","errcode","setTimeout","__awaiter","start","loginRawDigest","Date","now","rawSignature","privateKey","create","baseUrl","initialListener","event","initialEvent","timestamp","subscribe","MESSAGE","INVITE","member","content","members","updateRelayServer","updatePeerRoom","getPublicKeyHash","password","deviceId","console","reset","stop","isResolved","delete","MATRIX_PEER_ROOM_IDS","MATRIX_PRESERVED_STATE","listenForEncryptedMessage","senderPublicKey","messageCallback","has","sharedRx","createCryptoBoxServer","callbackFunction","isTextMessage","isSender","payload","message","sender","Buffer","from","_a","decryptedMessage","decryptionError","lastEvent","getTime","unsubscribe","unsubscribeFromEncryptedMessage","listener","unsubscribeFromEncryptedMessages","unsubscribeAll","clear","sendMessage","peer","sharedTx","createCryptoBoxClient","recipientHash","recipient","getRelevantRoom","waitForJoin","encryptedMessage","sendTextMessage","deleteRoomIdFromRooms","newRoomId","error2","split","startsWith","roomIds","room","push","newRoomIds","Object","entries","filter","entry","reduce","pv","cv","assign","listenForChannelOpening","isChannelOpenMessage","JSON","stringify","splits","pairingResponse","parse","senderId","getRoomById","Promise","sendPairingResponse","pairingRequest","createTrustedPrivateRoom","encryptMessageAsymmetric","msg","join","TEXT","senderHash","shift","manager","localStorage","getItem","TRANSPORT_P2P_PEERS_DAPP","TRANSPORT_P2P_PEERS_WALLET","peers","getPeers","promiseArray","map","hash","addPeer","all","getRelevantJoinedRoom","joinedRooms","relevantRooms","roomElement","some"],"sources":["../../../src/communication-client/P2PCommunicationClient.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module"}