{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { crypto_sign_ed25519_sk_to_curve25519, crypto_sign_ed25519_pk_to_curve25519, crypto_kx_server_session_keys, crypto_kx_client_session_keys } from 'libsodium-wrappers';\nimport { toHex, getHexHash, sealCryptobox } from '@airgap/beacon-utils';\n/**\n * @internalapi\n *\n *\n */\nexport class CommunicationClient {\n  constructor(keyPair) {\n    this.keyPair = keyPair;\n  }\n  /**\n   * Get the public key\n   */\n  getPublicKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return toHex(this.keyPair.publicKey);\n    });\n  }\n  /**\n   * get the public key hash\n   */\n  getPublicKeyHash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return getHexHash(this.keyPair.publicKey);\n    });\n  }\n  /**\n   * Create a cryptobox shared key\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n  createCryptoBox(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: Don't calculate it every time?\n      const kxSelfPrivateKey = crypto_sign_ed25519_sk_to_curve25519(Buffer.from(selfPrivateKey)); // Secret bytes to scalar bytes\n      const kxSelfPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(selfPrivateKey).slice(32, 64)); // Secret bytes to scalar bytes\n      const kxOtherPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(otherPublicKey, 'hex')); // Secret bytes to scalar bytes\n      return [Buffer.from(kxSelfPublicKey), Buffer.from(kxSelfPrivateKey), Buffer.from(kxOtherPublicKey)];\n    });\n  }\n  /**\n   * Create a cryptobox server\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n  createCryptoBoxServer(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n      return crypto_kx_server_session_keys(...keys);\n    });\n  }\n  /**\n   * Create a cryptobox client\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n  createCryptoBoxClient(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n      return crypto_kx_client_session_keys(...keys);\n    });\n  }\n  /**\n   * Encrypt a message for a specific publicKey (receiver, asymmetric)\n   *\n   * @param recipientPublicKey\n   * @param message\n   */\n  encryptMessageAsymmetric(recipientPublicKey, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return sealCryptobox(message, Buffer.from(recipientPublicKey, 'hex'));\n    });\n  }\n}","map":{"version":3,"names":["crypto_sign_ed25519_sk_to_curve25519","crypto_sign_ed25519_pk_to_curve25519","crypto_kx_server_session_keys","crypto_kx_client_session_keys","toHex","getHexHash","sealCryptobox","CommunicationClient","constructor","keyPair","getPublicKey","publicKey","getPublicKeyHash","createCryptoBox","otherPublicKey","selfPrivateKey","kxSelfPrivateKey","Buffer","from","kxSelfPublicKey","slice","kxOtherPublicKey","createCryptoBoxServer","keys","createCryptoBoxClient","encryptMessageAsymmetric","recipientPublicKey","message"],"sources":["../../../../src/transports/clients/CommunicationClient.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAGEA,oCAAoC,EACpCC,oCAAoC,EACpCC,6BAA6B,EAC7BC,6BAA6B,QACxB,oBAAoB;AAO3B,SAASC,KAAK,EAAEC,UAAU,EAAEC,aAAa,QAAQ,sBAAsB;AAEvE;;;;;AAKA,OAAM,MAAgBC,mBAAmB;EACvCC,YAA+BC,OAAgB;IAAhB,KAAAA,OAAO,GAAPA,OAAO;EAAY;EAElD;;;EAGaC,YAAYA,CAAA;;MACvB,OAAON,KAAK,CAAC,IAAI,CAACK,OAAO,CAACE,SAAS,CAAC;IACtC,CAAC;;EAED;;;EAGaC,gBAAgBA,CAAA;;MAC3B,OAAOP,UAAU,CAAC,IAAI,CAACI,OAAO,CAACE,SAAS,CAAC;IAC3C,CAAC;;EAED;;;;;;EAMgBE,eAAeA,CAC7BC,cAAsB,EACtBC,cAA0B;;MAE1B;MACA,MAAMC,gBAAgB,GAAGhB,oCAAoC,CAACiB,MAAM,CAACC,IAAI,CAACH,cAAc,CAAC,CAAC,EAAC;MAC3F,MAAMI,eAAe,GAAGlB,oCAAoC,CAC1DgB,MAAM,CAACC,IAAI,CAACH,cAAc,CAAC,CAACK,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,CAC1C,EAAC;MACF,MAAMC,gBAAgB,GAAGpB,oCAAoC,CAC3DgB,MAAM,CAACC,IAAI,CAACJ,cAAc,EAAE,KAAK,CAAC,CACnC,EAAC;MAEF,OAAO,CACLG,MAAM,CAACC,IAAI,CAACC,eAAe,CAAC,EAC5BF,MAAM,CAACC,IAAI,CAACF,gBAAgB,CAAC,EAC7BC,MAAM,CAACC,IAAI,CAACG,gBAAgB,CAAC,CAC9B;IACH,CAAC;;EAED;;;;;;EAMgBC,qBAAqBA,CACnCR,cAAsB,EACtBC,cAA0B;;MAE1B,MAAMQ,IAAI,GAAG,MAAM,IAAI,CAACV,eAAe,CAACC,cAAc,EAAEC,cAAc,CAAC;MAEvE,OAAOb,6BAA6B,CAAC,GAAGqB,IAAI,CAAC;IAC/C,CAAC;;EAED;;;;;;EAMgBC,qBAAqBA,CACnCV,cAAsB,EACtBC,cAA0B;;MAE1B,MAAMQ,IAAI,GAAG,MAAM,IAAI,CAACV,eAAe,CAACC,cAAc,EAAEC,cAAc,CAAC;MAEvE,OAAOZ,6BAA6B,CAAC,GAAGoB,IAAI,CAAC;IAC/C,CAAC;;EAED;;;;;;EAMgBE,wBAAwBA,CACtCC,kBAA0B,EAC1BC,OAAe;;MAEf,OAAOrB,aAAa,CAACqB,OAAO,EAAEV,MAAM,CAACC,IAAI,CAACQ,kBAAkB,EAAE,KAAK,CAAC,CAAC;IACvE,CAAC"},"metadata":{},"sourceType":"module"}